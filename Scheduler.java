import java.util.ArrayList;

/**
  * This class is designed to act as a scheduler to help determine possible schedules.
  */
public class Scheduler{

  private Course[] possibleCourses; //Array holding all the possible Courses to look at.
  //ArrayList containing all the possible schedules generated by the program.
  private ArrayList<Schedule> possibleSchedules = new ArrayList<Schedule>();
  public static final int MAX_COURSES = 5; //Maximum number of courses per student.

  /**
   * Construct a Scheduler instance and generates possible schedules.
   *
   * @param possibleCourses An array holding all the possible Courses to examine.
   * @post constructs a Scheduler instance.
   */
  public Scheduler(Course[] possibleCourses){
    this.possibleCourses = possibleCourses;
    generateSchedules();
  }

  /**
   * Checks for conflicts in timeslots between two courses.
   *
   * @pre two valid courses are passed in
   * @post returns boolean value representing the presence of a conflict.
   *
   * @param thisCourse one of the courses to examine
   * @param otherCourse other course to examine
   * @return true if there is a conflict, false otherwise.
   */
  private boolean checkConflicts(Course thisCourse, Course otherCourse){
    int[] thisTimeslots = thisCourse.getTimeslots();
    int[] otherTimeslots = otherCourse.getTimeslots();

    //Check for overlaps by seeing if one course starts in between the other course.
    for(int i = 0; i < thisTimeslots.length; i += 2){
      for(int j = 0; j < otherTimeslots.length; j += 2){
        if(thisTimeslots[i] <= otherTimeslots[i + 1] &&
          thisTimeslots[i + 1] > otherTimeslots[j]) return true;
        else if(otherTimeslots[j] <= thisTimeslots[i] &&
          otherTimeslots[j + 1] > thisTimeslots[i]) return true;
      }
    }

    return false;
  }

  /**
   * Generates all possible Schedules.
   *
   * @pre possibleCourses has been initialized, possibleCourses.length > MAX_COURSES
   * @post possibleSchedules is populated with all possible schedules.
   */
  private void generateSchedules(){
    ArrayList<Course> chosen = new ArrayList<Course>();

    generateScheduleHelper(chosen, 0, false);
  }

  /**
   * Helper method that generates courses recursively.
   *
   * @pre two valid courses are passed in
   * @post possibleSchedules is populated with all possible schedules.
   *
   * @param chosen ArrayList of courses that are possible thus far.
   * @param currIndex index of the course currently examined.
   * @param courseAdded boolean indicating whether a course was added with the
   *                    last recursion.
   */
  private void generateScheduleHelper(ArrayList<Course> chosen, int currIndex,
                                      boolean courseAdded){

    //if a course was added with the last level of recusion, add the new list
    //of chosen courses as a possible schedule.
    //TODO: when a more complete Courses.csv is created, add a condition to only
    //show schedules >= 4 courses.
    if(courseAdded) possibleSchedules.add(new Schedule(chosen));

    //exit conditions: all courses are considered, or max schedule size is reached.
    if(currIndex == possibleCourses.length) return;
    else if(chosen.size() == MAX_COURSES) return;

    //calls the next level without adding the course being examined.
    generateScheduleHelper(chosen, currIndex + 1, false);

    //checks if the course can be added to current schedule
    for(int i = 0; i < chosen.size(); i++){

        //if there is a conflict nothing is done.
        if(checkConflicts(chosen.get(i), possibleCourses[currIndex])) break;

        //else add it to the schedule, and calls the next level of recursion.
        else if(i == chosen.size() - 1) {
          chosen.add(possibleCourses[currIndex]);
          generateScheduleHelper(chosen, currIndex + 1, true);
        }
    }
  }
}
